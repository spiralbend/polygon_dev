<!DOCTYPE html>
<html lang="en">
<head>
	<title>Particle Party</title>
	<meta charset="utf-8">
	<meta name="viewport" content="width=device-width, user-scalable=no, minimum-scale=1.0, maximum-scale=1.0">
	<link type="text/css" rel="stylesheet" href="min.css">
</head>
	<body bgcolor=black>
<script async src="https://unpkg.com/es-module-shims@1.3.6/dist/es-module-shims.js"></script>
<script type="importmap">
	{
		"imports": {
			"three": "./three.js/build/three.module.js"
		}
	}
</script>
<script type="x-shader/x-vertex" id="vertexshader">
	attribute float scale;
	void main() {
		vec4 mvPosition = modelViewMatrix * vec4( position, 1.0 );
		gl_PointSize = 3.0 * scale * ( 300.0 / - mvPosition.z );
		gl_Position = projectionMatrix * mvPosition;
	}
</script>
<script type="x-shader/x-fragment" id="fragmentshader">
	uniform vec3 color;
	uniform sampler2D pointTexture;
	void main() {
		if ( length( gl_PointCoord - vec2( 0.5, 0.5 ) ) > 0.475 ) discard;
		gl_FragColor = vec4( color, 1.0 );
		gl_FragColor = gl_FragColor * texture2D( pointTexture, gl_PointCoord );
	}
</script>
<script type="module">
import * as THREE from 'three';
import { OrbitControls } from './three.js/examples/jsm/controls/OrbitControls.js';

let container, camera, scene, renderer, light, ambientLight; const PI = Math.PI
var points, geometry, controls, animid, numParticles, numP3, positions, colors, scales, windowHalfX, windowHalfY
var frames = 0, zoom = 1, rotate = false, stopped = false, pix = 5, dr = 0.0025, rev = 2 * PI / dr, time = 0, dt = 0.005
var numParticles = 300, numP3 = numParticles * 3, boxX = 600, boxY = 600, boxZ = 600, pos = [], vel = [], acc = [], mss = []

// START
init()
animate()

function render() {

	camera.lookAt( scene.position )
	positions = points.geometry.attributes.position.array
	colors = points.geometry.attributes.color.array
	scales = points.geometry.attributes.scale.array

	//if (frames % 100 == 0) {  }
	//scales[0] = 10

	
	if (rotate) { 
		points.rotateX(dr)
		if ((frames % rev) < 400) { points.rotateY(dr/2); points.rotateZ(dr/3) }
	}

	pos[0].x = 1000 * Math.sin(time)
	pos[0].y = 500  * Math.sin(time) * Math.cos(time)
	pos[0].z = 250  * Math.cos(1.2*time)

	for (let k=1; k<numParticles; k++) {
		let v = new THREE.Vector3().copy(pos[k])
		v.sub(pos[0]).divideScalar(-50*(mss[k])**1.5)
		vel[k].add(v)
	}
	
	time += dt * (1.2 + Math.sin(time))/2
	let idx = 0

	for ( let j = 0; j < numParticles; j++) {
		
		pos[j].add(vel[j])
		let X = pos[j].x
		let Y = pos[j].y
		let Z = pos[j].z
		let limx = boxX, limy = boxY, limz = boxZ

		 if (j != 0) {
			for (let k=1; k<numParticles; k++) {
				if (k == j) { continue }
				let v = new THREE.Vector3().copy(pos[k])
				let d = Math.pow(mss[j]*v.distanceTo(pos[j]), -1.9)
				v.sub(pos[j]).multiplyScalar(d)
				vel[j].add(v)
			}
			// if (X >  limx) { X =  limx; vel[j].x *= -1 }
			// if (X < -limx) { X = -limx; vel[j].x *= -1 }
			// if (Y >  limy) { Y =  limy; vel[j].y *= -1 }
			// if (Y < -limy) { Y = -limy; vel[j].y *= -1 }
			// if (Z >  limz) { Z =  limz; vel[j].z *= -1 }
			// if (Z < -limz) { Z = -limz; vel[j].z *= -1 }
		}

		positions[idx]   = X
		positions[idx+1] = Y
		positions[idx+2] = Z
		scales[j] = mss[j]
	
		idx += 3
	}

	points.geometry.attributes.position.needsUpdate = true
	points.geometry.attributes.color.needsUpdate = true
	points.geometry.attributes.scale.needsUpdate = true
	renderer.render( scene, camera )
	frames++

}

function makeGeometry() {

	if (frames > 0) {
		var x = points.rotation.x
		var y = points.rotation.y
		var z = points.rotation.z
		scene.remove( points )
	}

	var positions = new Array(numP3), colors = new Array(numP3), scales = new Float32Array( numParticles )
	var geometry = new THREE.BufferGeometry()

	geometry.setAttribute( 'position', new THREE.Float32BufferAttribute( positions, 3 ) )
	geometry.setAttribute( 'color', new THREE.Float32BufferAttribute( colors, 3 ) )
	geometry.setAttribute( 'scale', new THREE.BufferAttribute( scales, 1 ) )

	//const sprite = new THREE.TextureLoader().load( './files/circle.png' )
	//var material = new THREE.ShaderMaterial( { vertexShader: document.getElementById( 'vertexshader' ).textContent, vertexColors: false, alphaTest: 0.2, transparent: true } )
	const material = new THREE.ShaderMaterial( {

		uniforms: {
			color: { value: new THREE.Color( 0xffffff ) },
			pointTexture: { value: new THREE.TextureLoader().load( './files/ball.png' ) }
		},
		vertexShader: document.getElementById( 'vertexshader' ).textContent,
		fragmentShader: document.getElementById( 'fragmentshader' ).textContent,
		vertexColors: true

	} );
	points = new THREE.Points( geometry, material )
	scene.add( points )

	pos.push(new THREE.Vector3(0,0,0))
	vel.push(new THREE.Vector3(0.3,0.4,0.5))
	mss.push(150)

	for (let i=1; i<numParticles; i++) {
		pos.push( new THREE.Vector3( Math.random()*boxX*flip()/5, Math.random()*boxY*flip()/5, Math.random()*boxZ*flip()/5) )
		vel.push( new THREE.Vector3( Math.random() * flip(), Math.random() * flip(), Math.random() * flip() ) )
		mss.push( Math.random()*50 + 25)
	}

	// console.log(pos[0], pos[1])
	// let v = new THREE.Vector3().copy(pos[0])
	// v.sub(pos[1]).divideScalar(100)
	// console.log(pos[0], pos[1], v)

	if (frames > 0) { 
		points.rotateX(x)
		points.rotateY(y)
		points.rotateZ(z)
	}

	if (frames == 0) {
		console.log("pts", numParticles, "\nxyz", numP3, "\ncam", camera.position.x.toFixed(0), camera.position.y.toFixed(0), camera.position.z.toFixed(0) )
	}

}

function init() {
	ambientLight = new THREE.AmbientLight( 0x404040 )
	light = new THREE.DirectionalLight( 0xFFFFFF, 1.0 )
	light.position.set( 0.32, 0.39, 0.7 )

	container = document.createElement( 'div' )
	document.body.appendChild( container )
	camera = new THREE.PerspectiveCamera( 45, window.innerWidth / window.innerHeight, 2, 10000 )
	camera.position.set( 0, 0, 5000 )
	scene = new THREE.Scene()

	renderer = new THREE.WebGLRenderer( { antialias: true } )
	renderer.setPixelRatio( window.devicePixelRatio )
	renderer.setSize( window.innerWidth, window.innerHeight )
	container.appendChild( renderer.domElement )

	controls = new OrbitControls( camera, renderer.domElement )
	controls.enableDamping = true
	controls.dampingFactor = 0.05
	controls.screenSpacePanning = true
	window.addEventListener( 'resize', onWindowResize )

	scene.add( ambientLight )
	scene.add( light )

	makeGeometry()
}

function animate() {
	animid = requestAnimationFrame( animate )
	controls.update()
	render()
}

function flip() {
	if (Math.random() > 0.5) {
		return 1
	} else {
		return -1
	}
}

document.body.style.overflow = 'hidden'
document.onkeydown = function(e) {
	switch (e.keyCode) { 
		case 8: e.preventDefault(); init(); break //backspace
		case 187: zoom *= 1.05; break //+
		case 189: zoom /= 1.05; break //-
		case 220: zoom = 1; camera.position.set( 0, 0, 1000 ); break //\
		case 27: //ESC stop
			if(stopped) {
				animate()
				stopped = false
				//document.getElementById('esh').innerHTML = "&nbsp;";
			} else {
				cancelAnimationFrame(animid);
				stopped = true
			}
			break
	}
}

function onWindowResize() {
	windowHalfX = window.innerWidth / 2
	windowHalfY = window.innerHeight / 2
	camera.aspect = window.innerWidth / window.innerHeight
	camera.updateProjectionMatrix()
	renderer.setSize( window.innerWidth, window.innerHeight )
}
		</script>
	</body>
</html>
